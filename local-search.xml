<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络笔记"><a href="#计算机网络笔记" class="headerlink" title="计算机网络笔记"></a>计算机网络笔记</h1><p>[TOC]</p><h2 id="1、HTTP协议"><a href="#1、HTTP协议" class="headerlink" title="1、HTTP协议"></a>1、HTTP协议</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>超文本传输协议</p><p><strong>经典状态码</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p><p>304：发送请求资源时，比对当前客户端的缓存资源是否修改，如果没变，则重定向到缓存资源，改了则返回200</p><h3 id="1-2-常见字段-经典参数"><a href="#1-2-常见字段-经典参数" class="headerlink" title="1.2 常见字段 + 经典参数"></a>1.2 常见字段 + 经典参数</h3><ul><li>Host 指定服务器域名 （<a href="http://www.xxxx.com)/">www.xxxx.com）</a></li><li>Content-length 表面本次返回数据的长度 （1000）</li><li>Connection 客户端要求服务端TCP持久连接，以便请求复用 （keep-alive）</li><li>Content-Type 告诉客户端本次数据是什么格式 （text/html;charset=utf-8)</li><li>Content-Encoding 说明数据压缩的方法 （gzip）</li><li>Accept-Encoding 客户端说明自己接受什么样的压缩方法</li></ul><h2 id="2、GET和POST"><a href="#2、GET和POST" class="headerlink" title="2、GET和POST"></a>2、GET和POST</h2><h3 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h3><ul><li>GET 从服务器获取资源，安全切幂等（不会修改资源，并且每次结果都相同）</li><li>POST 根据请求负荷对指定资源做出处理，不安全不幂等（会修改服务器上的资源，多次提交会创建多个资源）</li></ul><h2 id="3、HTTP缓存"><a href="#3、HTTP缓存" class="headerlink" title="3、HTTP缓存"></a>3、HTTP缓存</h2><h3 id="3-1-强制缓存"><a href="#3-1-强制缓存" class="headerlink" title="3.1 强制缓存"></a>3.1 强制缓存</h3><p>判断浏览器缓存过没过期，没过期直接使用浏览器本地缓存，浏览器具有主动性</p><p><strong>依赖两个头部</strong></p><ul><li>Cache-Control 相对时间</li><li>Expires 绝对时间</li></ul><p>Cache-Control 优先级高于 Expires</p><p>浏览器第一次请求访问服务器，会返回一个响应头中带有Cache-Control ，设置了过期时间。</p><p>服务器若再次收到请求，会更新响应头中的Cache-Control</p><h3 id="3-2-协商缓存"><a href="#3-2-协商缓存" class="headerlink" title="3.2 协商缓存"></a>3.2 协商缓存</h3><p><strong>两个头部</strong></p><p>1、</p><ul><li>响应头中的 Last-Modified 资源最后一次修改时间</li><li>请求头中的 If-Modified-Since 若收到的响应头中有Last-Modified，再次发送时带上这个Last-Modified，与被请求资源的Last-Modified对比，如果大于，则说明过期，小于则返回304告诉你走本地缓存。</li></ul><p>2、</p><ul><li>响应头 If-None-Match  当本地缓存发现过期时，响应头里还有eTag ，则再次带上eTag请求一遍，与服务器资源的eTag对比，没变则返回304，变了返回200</li><li>请求头 eTag  唯一表示资源版本标识</li></ul><p><img src="https://img-blog.csdnimg.cn/d92026ce085b401c95cf02b7ce9b7fae.png" alt="img"></p><h2 id="4、HTTP-2-优化在哪"><a href="#4、HTTP-2-优化在哪" class="headerlink" title="4、HTTP/2 优化在哪"></a>4、HTTP/2 优化在哪</h2><p>HTTP/2 对报文的header部分做了改造，不使用以前的gzip来压缩头部，使用HPACK算法。</p><p>HPACK组成：</p><ul><li>静态表</li><li>动态表</li><li>Huffman编码</li></ul><h3 id="4-1-静态表"><a href="#4-1-静态表" class="headerlink" title="4.1 静态表"></a>4.1 静态表</h3><p>静态表是写在HTTP/2 框架中的表，有61中常出现的头部，比如method，server，path等，发送http2 报文头部可以压缩成二进制表示。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A82.png" alt="img"></p><h3 id="4-2-动态表"><a href="#4-2-动态表" class="headerlink" title="4.2 动态表"></a>4.2 动态表</h3><p>不属于那61个常用头部的头部，就需要服务端自己创建动态表，将新出现的头部接着61加下去，下一个就是62，下一次客户端发送这个头部的时候，就不需要重复发这个字段，只需要发index服务端就可以查到是哪个头部了。</p><p><strong>所以，必须要在同一个连接上，重复传输完全相同的http头部，这个功能才能发挥作用</strong>，当然避免动态表过于庞大，请求数量到达上限时就会关闭http连接，示范内存。</p><h3 id="4-3-二进制帧"><a href="#4-3-二进制帧" class="headerlink" title="4.3 二进制帧"></a>4.3 二进制帧</h3><p>HTTP/2 性能提升最大的还是数据的改变，HTTP 1使用文本传输，HTTP2直接使用二进制数据传输，大大提高了服务端的解析效率。</p><p>HTTP/2 把响应报文划分成两个帧，头部帧和数据帧，每个帧的结构如下</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="img"></p><p>后面的帧数据则是使用HPACK算法压缩的数据。</p><h3 id="4-4-并发Stream-传输"><a href="#4-4-并发Stream-传输" class="headerlink" title="4.4 并发Stream 传输"></a>4.4 并发Stream 传输</h3><p>HTTP/2 使用stream达到并发传输的目的，多个stream复用一个TCP连接，不像HTTP/1.1 那样纯靠多个TCP连接堆起来实现并发。每个Stream 都有StreamID 这个ID时后续为两端提供有序组装的消息，所以Stream可以乱序发送，但是一个Stream里面的帧必须是有序的。</p><p>客户端发送的StreamID必须是奇数，服务端是偶数。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream2.png" alt="img"></p><h3 id="4-5-服务器主动推送资源"><a href="#4-5-服务器主动推送资源" class="headerlink" title="4.5 服务器主动推送资源"></a>4.5 服务器主动推送资源</h3><p>客户端请求一个数据，服务端则会把这个数据包括以后可能会使用上的其他的数据发给他，顺带上的是以一个PUSH_PROMISE帧，告诉客户端接下来哪个Stream发送资源，</p><h2 id="5、TCP协议"><a href="#5、TCP协议" class="headerlink" title="5、TCP协议"></a>5、TCP协议</h2><p>TCP 是一个面向连接，可靠的，基于字节流的传输层通信协议。</p><h3 id="5-1-TCP-三次握手"><a href="#5-1-TCP-三次握手" class="headerlink" title="5.1 TCP 三次握手"></a>5.1 TCP 三次握手</h3><ul><li>服务端主动监听某个端口</li><li>客户端初始化序号 client_isn，放在TCP首部的序号字段中，并把SYN标志位置为1，接着就发给服务端，这次报文不带有应用层数据，之后客户端处于 SYN_SENT状态</li><li>服务端收到SYN报文后，也初始化自己的序号 server_isn ，填入当前TCP报文首部的序号字段，在确认应答号字段填入 client_isn+1，接着把SYN和ACK标志位置为1，然后发回给客户端，此报文也不带应用层数据。</li><li>客户端收到返回的报文后，ACK标志位置为1，在确认应答号填入 server_isn+1，此次可以携带应用层数据，然后发给服务端，处于ESTABLISHED 状态</li><li>服务端收到应答报文后，进入ESTABLISHED 状态。</li></ul><h3 id="5-2-为什么要三次握手"><a href="#5-2-为什么要三次握手" class="headerlink" title="5.2 为什么要三次握手"></a>5.2 为什么要三次握手</h3><p>三个原因：</p><ul><li><strong>三次握手才可以阻止重复历史连接的初始化</strong></li><li>三次握手才能同步双方初始序列号</li><li>三次握手避免资源浪费</li></ul><h4 id="组织历史连接初始化"><a href="#组织历史连接初始化" class="headerlink" title="组织历史连接初始化"></a>组织历史连接初始化</h4><p>首要原因是为了防止旧的重复连接初始化造成混乱，如果只是一来一回就建立好了连接，那么如果第一次握手阻塞的话，即是历史连接，那么后来新的连接会受到这个历史连接的影响，例如老的比新的先到服务端的期望ack 值以及不是历史期望，就会把当前这个连接中断作废，导致资源浪费或者建立多的无用且冗余连接。</p><p><strong>初始化序列号</strong></p><p>每次连接初始化的序列号必须不同。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统笔记"><a href="#操作系统笔记" class="headerlink" title="操作系统笔记"></a>操作系统笔记</h1><p>[TOC]</p><h1 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h1><h2 id="1、存储器的结构"><a href="#1、存储器的结构" class="headerlink" title="1、存储器的结构"></a>1、存储器的结构</h2><h3 id="1-1-CPU内部结构"><a href="#1-1-CPU内部结构" class="headerlink" title="1.1 CPU内部结构"></a>1.1 CPU内部结构</h3><p>时钟周期看cpu频率，如2GHz，时钟周期为 1/2G s = 0.5 ns</p><ul><li>CPU寄存器 （半个时钟周期）</li><li>L1 Cache</li><li>L2 Cache</li><li>L3 Cache</li></ul><h3 id="1-2-内存条"><a href="#1-2-内存条" class="headerlink" title="1.2 内存条"></a>1.2 内存条</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="img"></p><h2 id="2、如何让CPU运行代码运行地更快"><a href="#2、如何让CPU运行代码运行地更快" class="headerlink" title="2、如何让CPU运行代码运行地更快"></a>2、如何让CPU运行代码运行地更快</h2><h3 id="1-提升缓存命中率（L1-Cache）"><a href="#1-提升缓存命中率（L1-Cache）" class="headerlink" title="1. 提升缓存命中率（L1 Cache）"></a>1. 提升缓存命中率（L1 Cache）</h3><ul><li>数据缓存，遍历数据，按照内存布局地顺序操作，就是Cpu Cache Line 在从内存中读取数据的时候，由于需要读满，就会把当前内容之后的能够填满空间的数据量一并载入Cpu Cache中，之后的一些读数据就可以从CPU Cache中读到，而不用去内存中读。</li><li>指令缓存，让分支预测器发挥它的作用，尽量有规律一些。</li></ul><h2 id="3、CPU缓存一致性"><a href="#3、CPU缓存一致性" class="headerlink" title="3、CPU缓存一致性"></a>3、CPU缓存一致性</h2><p>在多核CPU中需要考虑到缓存的一致性</p><blockquote><p>对于数据的写入，CPU 都会先写入到 Cache 里面，然后再在找个合适的时机写入到内存，那就有「写直达」和「写回」这两种策略来保证 Cache 与内存的数据一致性：</p><ul><li>写直达，只要有数据写入，都会直接把数据写入到内存里面，这种方式简单直观，但是性能就会受限于内存的访问速度；</li><li>写回，对于已经缓存在 Cache 的数据的写入，只需要更新其数据就可以，不用写入到内存，只有在需要把缓存里面的脏数据交换出去的时候，才把数据同步到内存里，这种方式在缓存命中率高的情况，性能会更好；</li></ul></blockquote><h3 id="3-1-实现缓存一致性"><a href="#3-1-实现缓存一致性" class="headerlink" title="3.1 实现缓存一致性"></a>3.1 实现缓存一致性</h3><p>实现缓存一致性需要满足两点</p><ul><li>写传播，即是一个CPU的核中CPU Cache在发生写操作时，将这个操作通过总线传播给其他核心</li><li>事务的串行化，传播出去了，当然要考虑执行顺序，不然会导致不同核心收到的顺序不同，导致数据不一致，所以需要保证事物的串行化，程序在不同核心上运行的结果才会一致。</li></ul><p>解决方案：</p><p><strong>基于总线嗅探机制的MESI协议</strong></p><ul><li><p>总线嗅探：</p><ul><li>当一个CPU核心修改了L1 Cache中的一个值，会通过总线广播告知其他核心，其他核心则会一致监听总线上的广播事件，然后其他cpu核心会检查自己的L1 Cache中有没有这个变量，有的话就要修改更新。</li><li>这种方法不能保证事务的串行化。</li></ul></li><li><p>MESI协议</p><ul><li><em>Modified</em>，已修改<ul><li>这个状态就是脏数据，即以前已经修改过了，但是还没有写入内存</li></ul></li><li><em>Exclusive</em>，独占<ul><li>表示当前数据只被一个核心拥有，该核心可以对当前数据做任何修改而不用通过总线传播给其他核心</li></ul></li><li><em>Shared</em>，共享<ul><li>表示当前的数据为多个核心拥有，当一个核心想要修改这个数据的时候，需要先向其他CPU核心广播一个请求，让其他核心先把它们Cache中的此数据标记为失效状态，然后再更新当前的数据</li></ul></li><li><em>Invalidated</em>，已失效<ul><li>表示当前Cache Block里的数据已经失效，不可以读取该状态的数据</li></ul></li></ul></li></ul><blockquote><p>所以，可以发现当 Cache Line 状态是「已修改」或者「独占」状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力。</p></blockquote><h2 id="4、CPU如何执行任务"><a href="#4、CPU如何执行任务" class="headerlink" title="4、CPU如何执行任务"></a>4、CPU如何执行任务</h2><h3 id="4-1-CPU结构"><a href="#4-1-CPU结构" class="headerlink" title="4.1 CPU结构"></a>4.1 CPU结构</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E4%BC%AA%E5%85%B1%E4%BA%AB/CPU%E6%9E%B6%E6%9E%84.png" alt="img"></p><h3 id="4-2、CPU选择线程"><a href="#4-2、CPU选择线程" class="headerlink" title="4.2、CPU选择线程"></a>4.2、CPU选择线程</h3><p>Linux中任务分为 <strong>普通任务</strong> 和 <strong>实时任务</strong> </p><ul><li>实时任务：对系统响应要求很高，要尽快完成任务，所以优先级很高，在0-99范围内</li><li>普通任务：对响应时间没有要求，优先级在100-139内</li></ul><h4 id="调度类"><a href="#调度类" class="headerlink" title="调度类"></a>调度类</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E4%BC%AA%E5%85%B1%E4%BA%AB/%E8%B0%83%E5%BA%A6%E7%B1%BB.png" alt="img"></p><ul><li>Deadline 和 Realtime 调度类都是实时任务的，有三种调度策略<ul><li>Sched_DeadLine 这种调度会让靠近当前时间点的deadline任务优先调度</li><li>SCHED_FIFO 优先级相同的任务应用先来先服务，优先级更高的任务可以抢占优先级低的任务，即插队</li><li>SCHED_RR  优先级相同的任务轮流执行，时间片用完的任务进入队尾等待轮到自己，优先级高的也可以抢占</li></ul></li><li>Fair 用于普通任务<ul><li>SCHED_NORMAL普通任务调度</li><li>SCHED_BATCH 后台任务调度，不和终端进行交互，可以降低其优先级。</li></ul></li></ul><h3 id="4-3、CFS-完全公平调度（针对普通任务）"><a href="#4-3、CFS-完全公平调度（针对普通任务）" class="headerlink" title="4.3、CFS 完全公平调度（针对普通任务）"></a>4.3、CFS 完全公平调度（针对普通任务）</h3><p>理念：想让分配给每个任务的CPU时间是一样的，所以就给每个任务都加一个虚拟运行时间 vruntime，一个任务运行的越久 vruntime越大，然而CFS调度的时候，优先调度vruntime小任务，就跟分水喝一样，运行时间短的任务当然要多分配点时间给它，这样才能打到比较公平的对待。</p><p><strong>计算vruntime公式： vruntime += 实际运行时间 * nice / 权重</strong></p><p>nice 级别越低，权重越大，那么权重越大，vruntime就越小，就会被优先执行。</p><p>任务nice值的分布范围 -20 ~ 19 ，nice不是表示优先级，而是表示对优先级的修正量， 与优先级的关系 </p><p><strong>priority（new） = priority（old） + nice</strong>，这样看nice值越小（为负），优先级越高，优先级范围是 0<del>139 其中 0</del>99 是实时任务使用，100~139 是普通任务使用，所以nice值调整的是普通任务的优先级。想要让一个普通任务优先执行可以调整他的nice值，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">//在启动任务的时候调整：<br>$ <span class="hljs-built_in">nice</span> -n -3 /usr/sbin/mysqld<br>//任务运行时调整<br>$ renice -10 -p &lt;进程PID&gt;<br></code></pre></td></tr></table></figure><h2 id="5、进程的通信"><a href="#5、进程的通信" class="headerlink" title="5、进程的通信"></a>5、进程的通信</h2><h3 id="5-1、进程的通信方式"><a href="#5-1、进程的通信方式" class="headerlink" title="5.1、进程的通信方式"></a>5.1、进程的通信方式</h3><ul><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>信号</li><li>Socket</li></ul><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>内核里的一段缓存，写入数据实际写入内存，读也是从内存读取，</p><p>Linux 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ A | B<br></code></pre></td></tr></table></figure><p>数据传输是单向的，如果要实现双向通信就要建立两个管道，**|** 这个符号是匿名管道，要建立命名管道</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkfifo</span> mypipe<br></code></pre></td></tr></table></figure><p>写入数据和读取数据是分开的，读完之后就会销毁管道，通信效率很低，不适合频繁通信。匿名管道依赖于父子进程的关系，命名管道则不依赖，数据遵循先进先出。</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>保存在内存中的消息链表</p><p>A 进程把数据放在消息队列里，B进程自己去消息队列中取出，可以双向，发送出的数据是一个个消息体，消息体是用户自定义的数据类型，发送方和接收方约定好数据类型，消息体是固定大小的存储块，消息块一旦被读取，在内存中便会被删除，不主动释放消息队列，或者关闭操作系统，消息队列会一直存在。但是由于消息队列是存储在内核中，所以写入和读出都会产生用户态和内核态之间的数据拷贝开销。</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存解决了用户态和内核态之间消息拷贝的问题，进程中的虚拟空间指向的物理地址是相同的，所以就直接存取，不需要传来传去。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><ul><li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p>针对TCP协议通信的Socket</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/12-TCP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img"></p><p>针对UDP通信的Socket模型</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/13-UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img"></p><p><strong>Socket 本地和远程通信的区别</strong></p><ul><li><p><strong>本地Socket</strong>  首先，本地Socket编程接口和ipv4，ipv6套接字编程接口一样，但是本地的数据报和字节流要比前两者实现效率更高。</p><p>其次就是本地Socket在bind的时候不需要绑定ip和端口，绑定的是一个本地文件。</p></li><li><p>远程Socket需要绑定ip和端口，并且依赖于TCP或者UDP。</p></li></ul><h2 id="6、进程调度、页面置换、磁盘调度算法"><a href="#6、进程调度、页面置换、磁盘调度算法" class="headerlink" title="6、进程调度、页面置换、磁盘调度算法"></a>6、进程调度、页面置换、磁盘调度算法</h2><h3 id="1、进程调度算法"><a href="#1、进程调度算法" class="headerlink" title="1、进程调度算法"></a>1、进程调度算法</h3><ul><li>非抢占式调度（运行 -&gt; 等待，运行 -&gt; 终止）</li><li>抢占式调度 （运行 -&gt; 就绪，就绪 -&gt; 运行）</li></ul><p><strong>先来先服务调度算法</strong></p><p>​    非抢占式，维持一个队列，每次从就绪队列选择最先进入的进程，然后一直运行直到退出或者被阻塞，才会继续进行下一个进程。</p><p>有利于长作业，适合CPU繁忙型，不适合I/O 繁忙型。</p><p><strong>最短作业优先算法</strong></p><p>​    抢占式，优先运行运行时间最短的进程，对于长作业不利，适合于高吞吐量的系统。</p><p><strong>高响应比优先算法</strong></p><p>​    权衡短作业与长作业，每次进程调度前先算号响应优先级，公式如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/26-%E5%93%8D%E5%BA%94%E6%AF%94%E5%85%AC%E5%BC%8F.jpg" alt="img"></p><p>优先运行高响应优先级的进程，服务时间一样，等待时间越长优先级越高，等待时间一样，运行时间越短优先级越高。</p><p><strong>时间片轮转调度算法</strong></p><p>​    每个进程分配一个时间片，时间片用完则保存当前CPU状态，释放进程，进程上下文切换，把CPU分配给其他进程。如果在时间片用完之前就完成了进程，则立马释放CPU。</p><p><strong>最高优先级调度算法</strong></p><p>​    从就绪队列中选择优先级最高的进程运行。优先级分为静态和动态优先级。</p><ul><li>静态优先级：一开始就分配好的优先级，不会改变。</li><li>动态优先级：随着时间推移增加进程的优先级。</li></ul><p><strong>多级反馈队列调度算法</strong></p><p>​    有多个队列，队列优先级从高到低，优先级越高时间片越短。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg" alt="多级反馈队列"></p><p>短作业优先级高会很快被处理完，所以时间片也短，如果高优先级队列的一个进程时间片用完了还没结束，就往下走到下一个队列的尾部，但同时时间片也会增加，算是一种权衡弥补。可以同时兼顾好长短作业，有较好的响应时间。</p><h3 id="2、页面置换算法"><a href="#2、页面置换算法" class="headerlink" title="2、页面置换算法"></a>2、页面置换算法</h3><p>​    缺页中断，当进程要从也内存中取数据，然后就去内存中查页表，发现页表中要查的那个页面失效了，则会发起缺页中断，去磁盘中查找该页面。查到之后，不同于其它中断直接执行下一个指令，缺页中断还是会重新执行这个指令。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="虚拟内存的流程"></p><p><strong>最佳页面置换算法</strong></p><p>​    这个算法只在理论中存在，并不能实现，因为需要知道未来页面访问的时间，选择未来最长时间不访问的页面。所以这个算法就作为衡量一个算法的效率。</p><p><strong>先进先出置换算法</strong></p><p>​    选择在内存中滞留时间很长的页面进行替换，最简单的，但性能并不是很好。</p><p><strong>最近最久未使用页面置换算法</strong></p><p>​    发生缺页时，选择最长时间没有访问的页面进行置换，不常用，虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。每次访问都需要更新这个链表</p><p><strong>时钟页面置换算法</strong></p><p>​    维持一个环形链表，类似于LRU算法，形如一个时钟，时针指向最老的页面，每个页面维持一个访问位，如果时针指向的页面的访问位为0，则置换这个页面，如果不是0，就访问位减一，时针指向下一个页面。</p><p><strong>最不常用算法</strong></p><p>需要为每个增加一个访问计数器，选择访问次数最少的页面进行只换，硬件上实现成本高。</p><h3 id="3、磁盘调度算法"><a href="#3、磁盘调度算法" class="headerlink" title="3、磁盘调度算法"></a>3、磁盘调度算法</h3><p><strong>先来先服务 <a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1">先来先服务</a></strong></p><p><strong>最短寻道优先 <a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88">最短寻道时间优先</a></strong></p><p><strong>扫描算法 <a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95">扫描算法</a></strong></p><p><strong>循环扫描算法 <a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95">循环扫描算法</a></strong></p><p><strong>LOOK 与C-LOOK <a href="https://xiaolincoding.com/os/5_schedule/schedule.html#look-%E4%B8%8E-c-look%E7%AE%97%E6%B3%95">LOOK C-LOOK</a></strong> </p><h2 id="7、Reactor-和-Proactor-高性能网络模式"><a href="#7、Reactor-和-Proactor-高性能网络模式" class="headerlink" title="7、Reactor 和 Proactor 高性能网络模式"></a>7、Reactor 和 Proactor 高性能网络模式</h2><h4 id="Reactor使用的是非阻塞同步网络模式："><a href="#Reactor使用的是非阻塞同步网络模式：" class="headerlink" title="Reactor使用的是非阻塞同步网络模式："></a>Reactor使用的是非阻塞同步网络模式：</h4><p>感知可以读写的事件</p><h4 id="Proactor用的是异步网络模式："><a href="#Proactor用的是异步网络模式：" class="headerlink" title="Proactor用的是异步网络模式："></a>Proactor用的是异步网络模式：</h4><p>感知已完成读写的事件。</p><p><strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，而 <strong>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong></p><h2 id="8、I-O-操作"><a href="#8、I-O-操作" class="headerlink" title="8、I/O 操作"></a>8、I/O 操作</h2><ul><li>阻塞</li><li>非阻塞</li><li>同步</li><li>异步</li></ul><h2 id="9、杂谈"><a href="#9、杂谈" class="headerlink" title="9、杂谈"></a>9、杂谈</h2><p>记录一些复盘出的不知道的东西。</p><p>32位CPU 一次计算 4 字节，64位一次计算 8 字节，32、64位为CPU的位宽。</p><p>冯诺依曼体系结构：运算器，存储器，控制器，输入设备，输出设备。</p><p>CPU寄存器，通用寄存，程序计数寄存，指令寄存器。</p><p>指令的内容到机器层面其实就是一串二进制的机器码，需要解析机器码，解析就要依赖CPU指令集，指令的解码。</p><p>CPU流水线，通常分为四个阶段，取得指令，指令译码，执行指令，数据回写。</p><p>程序CPU执行时间 = CPU时钟周期数 * 时钟周期时间（硬件决定）。</p><p>CPU寄存器采用的是SRAM 静态随机存储，内存用的是DRAM 动态随机存储（电容需要不断刷新），L1,L2 Cache 为cpu每个核心拥有，L3 多个核心公用。</p><p>Linux中进程和线程都是用 ==task_struct== 结构体表示，线程的结构体中部分资源是共享的进程资源。</p><p>中断分为硬中断和软中断，即为上半部分和下半部分，例如一个网卡收到网络包，触发硬件中断，把网卡中的数据存入内存中，然后在通知处理程序，进行下一阶段，软中断，处理一些复杂耗时的事务。</p><p>内存分段存在问题：内存碎片，外部内存碎片用内存交换，重置一下物理地址的空间，然后写入的时候就接着上一个内存物理地址下去。</p><p>内存交换的效率就太低了，因为是在硬盘上读写数据。</p><p>内存分页，虚拟和物理空间都切成一个固定的大小，就解决了内存碎片问题。</p><p>malloc分配的是虚拟内存，有两种情况，需要分配的内存小于128kB，用brk() 分配，即移动用户空间堆顶的指针，大于128kb的时候用mmaps() 在文件映射区分配。</p><p>操作系统为什么要内存管理和虚拟内存？</p><p>每个进程都有自己的页表，每个进程的虚拟空间都是私有的且相互独立的，可以解决多线程之间的地址冲突问题。</p><p>页表里的页表项除了地址之外，还有控制一个页的读写权限，标记该页是否存在，为内存访问提供更高的安全性。</p><p>内存分配的过程，应用程序用malloc函数申请内存，当程序读写了这块内存，CPU会访问这个虚拟内存，发现还没有映射到物理内存，就会触发缺页中断，进程从用户态切换到内核态，然后交给缺页中断函数处理，建立起虚拟内存和物理内存的映射。如果内存够的话就直接建立映射，不够的话就会进行内存回收。</p><p>内存回收分类：</p><ul><li>后台内存回收，物理内存紧张会唤醒kswapd 内核线程来回收内存，这个过程是异步的，不会阻塞进程进行。</li><li>直接内存回收，异步回收更不上进程内存申请的速度，就会开始直接回收，这个过程是同步的，也就是会阻塞进程执行。</li></ul><p>文件页和匿名页：</p><p>文件页是内核缓存的文件数据，都有对应的磁盘文件，所以回收的时候直接释放就行，前提是干净页，如果是脏页就得先写回到磁盘中，再释放。</p><p>匿名页就是没有实际载体的数据，所以在swap的时候就需要一个磁盘载体来保存匿名页，就是swap分区。</p><p>内存回收的swap机制，就是将很长一段时间没有访问的内存临时保存到磁盘中，然后释放掉这部分的内存，当那些程序需要运行的时候，再从磁盘恢复数据到内存中。</p><p>如果空闲的物理内存还不满足内存申请的大小，就会触发OOM机制，选择一些占用物理内存较高的进程杀死，释放内存资源，如果不够继续杀进程，直到有足够的内存分配。</p><p>OOM的算法是怎样的：使用的是内核的一个函数 oom_badness()，把系统中可以杀掉的进程全部扫描一遍并且打分，分数越高的进程月先被杀死，分数如何计算: </p><ol><li><p>进程已经使用的内存页面数 process_pages</p></li><li><p>每个进程的校准值，oom_score_adj，可以自行配置在 -1000 ~ 1000之间任意一个数值，计算公式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">points = process_pages + oom_score_adj*totalpages/<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></li></ol><p>如果想让一个线程如论如何也杀不死，就把他的校准值改成 -1000，一般都是很重要的系统服务配置为-1000，不建议将用户程序配置为-1000。    </p><p>进程的挂起状态就是不占用实际的物理内存的情况，与阻塞不同，阻塞中的进程还是占用着内存的，挂起即页表换出存入硬盘中。</p><p>PCB进程唯一的标识，PCB内涵了进程标识符，用户标识符，CPU信息（用于上下文切换），资源分配清单，进程控制和管理信息。</p><p>CPU上下文就是CPU寄存器和程序计数器的环境，进程的切换需要这两者的支持。</p><p>进程上下文切换一般发生在：进程时间片用完，进程等待资源进入挂起状态，进程sleep函数，进程优先级抢占，硬件中断。</p><p>用户线程是由用户级线程库函数管理的，操作系统不参与。</p><p>Linux 一切皆文件，文件的存储方式有顺序存储，链式存储，索引存储。</p><ul><li>顺序存储，定长，存取速度快，但是又内存碎片，文件不易扩展。</li><li>链式存储，无外部碎片，可以动态扩展，只能按照指针顺序读取，指针消耗空间</li><li>索引存储，可以随机访问，易于文件增删，索引表消耗空间</li></ul><p>空闲空间管理，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记</title>
    <link href="/2022/10/14/MySQL%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/10/14/MySQL%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-45讲笔记"><a href="#MySQL-45讲笔记" class="headerlink" title="MySQL 45讲笔记"></a>MySQL 45讲笔记</h1><h2 id="1、日志系统"><a href="#1、日志系统" class="headerlink" title="1、日志系统"></a>1、日志系统</h2><p>有点像redis的日志。</p><p>更新操作。</p><h3 id="redo-log："><a href="#redo-log：" class="headerlink" title="redo log："></a>redo log：</h3><p>​    这个日志会把更新的操作写入日志，在系统空闲的时候才更新到磁盘，如果每次更新都写入磁盘的话，io代价太大了，所以先写日志，再写磁盘。redo log是固定大小，结构类似于循环链表，可以这么解释，类似于双指针在链表上遍历，一个指针是write pos ，一个是checkpoint，writepos在前面写，checkpoint在后面追，并且更新里面的日志内容到磁盘中。当写指针到末端时，可以循环到开头再继续写，这样子作用下去，如果writepos快赶上checkpoint了，就要推进checkpoint，让writepos停下来不执行新的更新命令。</p><p><img src="C:\Users\TyanK\AppData\Roaming\Typora\typora-user-images\image-20220519154435476.png" alt="image-20220519154435476"></p><p>readlog保证数据库异常重启之前提交的记录不会丢失，这个称为crash-safe。</p><h3 id="binlog："><a href="#binlog：" class="headerlink" title="binlog："></a>binlog：</h3><p>server层的日志，因为一开始mysql没用InnoDB，就用这个binlog来做归档。与read log的区别。</p><p><img src="C:\Users\TyanK\AppData\Roaming\Typora\typora-user-images\image-20220519155013599.png" alt="image-20220519155013599"></p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>​    提交readlog的过程分为俩阶段，一个是数据更新至内存之后的写入readlog，状态变为prepare，然后在写入server层的binlog，在最后做事务提交，为了保证这俩日志逻辑上的一致，如果不使用这种提交，就会造成一些问题，比如在readlog提交完之后数据库异常重启，就会导致还没写入binlog，如果要做临时库的话，由于binlog不一样，就会导致与原库的值不同。若是先提交binlog，然后crash，还没写入readlog，这样异常重启的时候，由于没写入readlog按理这个事务是无效的，但是binlog里又有，就多了一个事务，恢复数据之后又与原库不同。</p><h3 id="主从复制实现："><a href="#主从复制实现：" class="headerlink" title="主从复制实现："></a>主从复制实现：</h3><p>一般主服务器用来写，从服务器用来读。</p><p>MySQL数据库主从复制的实现依赖于binlog，在主服务器上用binlog记录改变了数据的语句，然后从服务器的io线程负责从主服务器上拉取binlog内容，然后放到自己的relay log（从服务器的中继日志）中，最后从服务器中再执行realy log中的语句，使得主从服务器中的数据保持一致。</p><h2 id="2、事务隔离"><a href="#2、事务隔离" class="headerlink" title="2、事务隔离"></a>2、事务隔离</h2><p>有四种隔离级别：</p><ul><li><p>READ_UNCOMMITTED 读未提交</p><ul><li>一个事务还没提交的时候，它的变更能被其他事务看见，会有脏读情况。</li></ul></li><li><p>READ_COMMITTED 读提交</p><ul><li>一个事务提交之后，它的变更才能被其他事物看见，会有不可重复读情况。</li></ul></li><li><p>REPEATABLE_READ 可重复读</p><ul><li>一个事务在执行的过程中，它看见的数据跟它在启动时看到的数据是一致的，也是提交之后才能被其他事物看见，会有幻读情况。</li></ul></li><li><p>SERIALIZABLE 串行化</p><ul><li>每次读、写都要加锁，读写冲突时必须等前一个事务完成再接着执行。</li></ul></li></ul><p><strong>不宜使用长事务</strong>，会导致回滚日志占用了太多的空间。</p><p>一般都让autocommit = 1，这样就不会出现长事务，如果怕多个短事务开始这样多次的交互造成资源浪费，可以一开始用begin开始事务，后面使用 commit work and chain语法。</p><h2 id="3、索引"><a href="#3、索引" class="headerlink" title="3、索引"></a>3、索引</h2><p>索引常见模型：哈希表，有序数组，B+树。</p><p>哈希表Key—Value，适合等值查询，但是对于范围查询效率很低。</p><p>有序数组：在等值查询和范围查询都很优秀，但是插入数据效率很低，适合长期不更改的静态表。</p><p>B+树：N叉搜索树。</p><h4 id="innoDB-索引"><a href="#innoDB-索引" class="headerlink" title="innoDB 索引"></a>innoDB 索引</h4><p>innoDB中的索引使用B+树，一个索引对应一个B+树，索引分为主键索引（聚簇索引），非主键索引（二级索引）。在二级索引上的查找最终还是会跳到主键索引中，主键索引中储存了对象所有信息，所以二级索引的查找需要多扫描一颗B+树。</p><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>B+树维护索引的有序性，插入新值的时候会有些麻烦，所以一般使用非业务字段做主键并且自增，维护有序性，都是追加操作，不会挪动其他记录。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>例如在二级索引上查找一行，如果此时查找的是二级索引自身就带有的值，那么就不需要回到聚簇索引去找，这就叫覆盖索引。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>对表中的多了个建立索引，<strong>有一个最左前缀原则</strong>,找到符合条件的第一个数据。</p><p>建立联合索引如何安排索引内字段排序？</p><p>如果通过调整顺序能够少维护一个索引，那么这个顺序需要优先考虑采用。如果没办法少维护一个索引，那么就联合多个字段，让字段内存小的单独再作为一个单独索引。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>联合索引时，如果索引中的某一个联合字段不符合查找条件，那么将不会回表查询，这样减少回表次数。</p><p><img src="C:\Users\TyanK\AppData\Roaming\Typora\typora-user-images\image-20220523155606625.png" alt="image-20220523155606625"></p><h2 id="4、InnoDB对MVCC的实现"><a href="#4、InnoDB对MVCC的实现" class="headerlink" title="4、InnoDB对MVCC的实现"></a>4、InnoDB对MVCC的实现</h2><p>MVCC依赖于</p><ul><li>隐藏字段</li><li>Read View</li><li>undo log</li></ul><p>InnoDB通过对DB_TRX_ID 和Read View 来实现数据的可见性，如果不可见，InnoDB通过DB_ROLL_PTR找到undo log找到历史版本。</p><p><img src="C:\Users\TyanK\AppData\Roaming\Typora\typora-user-images\image-20220523160435387.png" alt="image-20220523160435387"></p><p>一行数据的组成。</p><h4 id="Read-View的组成"><a href="#Read-View的组成" class="headerlink" title="Read View的组成"></a>Read View的组成</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadView</span> &#123;</span><br>  <span class="hljs-comment">/* ... */</span><br>private:<br>  <span class="hljs-type">trx_id_t</span> m_low_limit_id;      <span class="hljs-comment">/* 大于等于这个 ID 的事务均不可见 */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_up_limit_id;       <span class="hljs-comment">/* 小于这个 ID 的事务均可见 */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_creator_trx_id;    <span class="hljs-comment">/* 创建该 Read View 的事务ID */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_low_limit_no;      <span class="hljs-comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span><br><br>  <span class="hljs-type">ids_t</span> m_ids;                  <span class="hljs-comment">/* 创建 Read View 时的活跃事务列表 */</span><br><br>  m_closed;                     <span class="hljs-comment">/* 标记 Read View 是否 close */</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数据可见性（RR，RC）"><a href="#数据可见性（RR，RC）" class="headerlink" title="数据可见性（RR，RC）"></a>数据可见性（RR，RC）</h5><p><img src="C:\Users\TyanK\AppData\Roaming\Typora\typora-user-images\image-20220523164000656.png" alt="image-20220523164000656"></p><ul><li>m_up_limit_id：目前出现过的最大的TRX_ID + 1</li><li>m_low_limit_id: m_ids里面最小的事务ID</li><li>m_ids ：创建快照时但是没有提交的事务ID列表。</li></ul><p><strong>Read Commited 在每次查询时都会生成Read View，Repeatable Read 只有在创建事务后第一次查询时才创建。</strong></p><p><strong>这就是Repeatable Read 解决不可重复读的关键所在</strong></p><h2 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h2><p>:one: DDL (Data Definition Language) 数据定义语言 ， CREATE、DROP、ALTER</p><p>:two: DML (Data Manipulation Language) 数据操纵语言 ，INSERT、UPDATE、DELETE</p><p>:three: DQL (Data Query Language) 数据查询语言 ，SELECT</p><p>:four: DCL (Data Control Language) 数据控制语言，GRANT、REVOKE</p><h2 id="MySQL-45-讲笔记："><a href="#MySQL-45-讲笔记：" class="headerlink" title="MySQL 45 讲笔记："></a>MySQL 45 讲笔记：</h2><h4 id="star-事务的隔离性以及MVCC是如何实现的"><a href="#star-事务的隔离性以及MVCC是如何实现的" class="headerlink" title=":star: 事务的隔离性以及MVCC是如何实现的"></a>:star: 事务的隔离性以及MVCC是如何实现的</h4><p>事务有 Read Committed、Read Uncommitted、Repeatable Read、Serialize 四种级别，其中MySQL默认使用RR。</p><p>RR 为可重复读，意思是在当前事务过程中，所读取到的结果和开始事务之前 的结果是一样的，不会被其他事务修改。</p><p>在RR级别的事务中，每一行数据可以有多个数据版本，并且每个版本都有自己的事务id（trx_id），事务开启时，会创建一个事务id数组，并且完成自己的可见性规则，数组保存的是当前开启了但未提交的事务id，数组里面事务id的最小值就是低水位，当前系统已经创建的事务的最大id+1设为高水位，低于低水位的事务id是在当前事务开启前就已经提交的事务，是可见的，高于高水位的事务id说明是还未启动的事务，不可见，处于两者之间的事务，如果这个trx_id 在这个数组中，就是未提交的事务，是不可见的，如果不在则说明是已经提交了的事务生成的，是可见的。</p><p>但是更新的时候，使用的都是当前读，为了防止修改丢失。</p><h4 id="1、为字符串创建索引（关注区分度）"><a href="#1、为字符串创建索引（关注区分度）" class="headerlink" title="1、为字符串创建索引（关注区分度）"></a>1、为字符串创建索引（关注区分度）</h4><ul><li>直接创建索引 :-1: 占用空间大</li><li>创建前缀索引 :raised_hand:  节省空间，但是会增加扫描次数，并且对覆盖索引有影响。</li><li>倒叙存储并且前缀索引 :+1: ，可以加大字符串区分度，不支持范围扫描。</li><li>创建hash字段索引 :+1: 查询性能稳定，但是会有额外空间和计算消耗，不支持范围扫描。</li></ul><h4 id="2、flush-redo-log-memo"><a href="#2、flush-redo-log-memo" class="headerlink" title="2、flush redo log :memo:"></a>2、flush redo log :memo:</h4><ul><li>redo log 写满了，即writepos 赶上了 checkpoint ，这时候就停下writepos，cp往前flush，刷到磁盘上。</li><li>系统内存满了，内存页不够用，需要换出脏页，刷到磁盘中，</li><li>空闲定时刷盘，有空闲时间就flush</li><li>MySQL正常关闭马，把所有脏页都flush到盘上。</li></ul><h4 id="3、表数据删除但是表文件大小不变-floppy-disk"><a href="#3、表数据删除但是表文件大小不变-floppy-disk" class="headerlink" title="3、表数据删除但是表文件大小不变 :floppy_disk:"></a>3、表数据删除但是表文件大小不变 :floppy_disk:</h4><ul><li>删除表中的数据后，表的结构依然存在，所删除的数据仅仅被标记为删除状态，在内存页中仍然置留着一部分空间，可以用来复用，所以删除数据并不能减小表文件大小。</li><li>所以要缩小文件大小，就需要重建表，因为重建表是按照索引顺序来存储的，这样子的索引就是紧凑的。</li><li>通过 <strong>alter table A engine=InnoDB</strong> 来重建表</li></ul><h4 id="4、count-x-随着数据量变大而变慢"><a href="#4、count-x-随着数据量变大而变慢" class="headerlink" title="4、count(x) 随着数据量变大而变慢"></a>4、count(x) 随着数据量变大而变慢</h4><ul><li>时间为遍历整张表的时间，并且count(主键) \  count(x) 还会取出值判断是否为空，尽量用count(*)，InnoDB开启了事务也不会造成并发问题。</li></ul><h4 id="5、order-by-如何实现的"><a href="#5、order-by-如何实现的" class="headerlink" title="5、order by 如何实现的"></a>5、order by 如何实现的</h4><ul><li>根据二级索引查找到 目标数据，然后通过主键索引查出数据并存入 sort_buffer中，然后进行快排，全字段排序。</li><li>rowid 排序 ，当一行的数据量过大时，sort_buffer 装不下全字段的数据，就从主键索引中取出能填满buffer的主键数据，然后进行排序，排完序后再从主键索引中读取数据，然后依次有序输出，因为过程会回表多，不会被优先使用。</li><li>还有一种不需要排序方法，可以直接创建需要排序字段的联合索引+需要查询的属性字段 形成一个覆盖索引，然后可以直接取出，因为这时候索引是有序的，就不需要排序，需要权衡维护索引和排序哪个更合适当前业务。</li></ul><h4 id="6、MySQL-如何优雅随机取值"><a href="#6、MySQL-如何优雅随机取值" class="headerlink" title="6、MySQL 如何优雅随机取值"></a>6、MySQL 如何优雅随机取值</h4><ul><li>order by rand() limit 3 :-1:   这样就扫描全表了，还会创建临时表，浪费计算资源，limit 走的是rowid排序，然后取前三行。</li><li>随机函数生成一个X，id为主键，X = floor(max(id) - min(id)) *rand() + N，执行三次，:-1: 遇到主键id不紧凑的情况直接寄。</li><li>取得表所有行数 C，Y = floor(C*rand()) ，floor为取下一个整数值，加用limit Y 1 取Y后第一行，执行三次，获取三次Y，:+1:</li></ul><h4 id="7、SQL语句逻辑相同，但执行效率不一样"><a href="#7、SQL语句逻辑相同，但执行效率不一样" class="headerlink" title="7、SQL语句逻辑相同，但执行效率不一样"></a>7、SQL语句逻辑相同，但执行效率不一样</h4><ul><li>可能没有走索引，例如对索引字段使用了函数之类的，但是在输入参数使用函数还是可以走索引的，可以用explain命令来查看语句执行结果。</li><li>隐式类型转换，例如字符串转数字，本身字段是字符串型，但是搜索得条件是int型，就会触发字符串型转换为int型，导致无法使用索引。</li><li>隐式编码转换，多表查询时，如果两个表所使用得编码字符集不一的话，会触发不同字符集之间的自动转换，这就需要调用转型函数，间接触发了第一种情况，如果不能让两个表的编码一致，可以在输入参数上使用编码转换函数，这样还是可以走索引的。</li></ul><h4 id="8、查询语句慢的可能原因"><a href="#8、查询语句慢的可能原因" class="headerlink" title="8、查询语句慢的可能原因"></a>8、查询语句慢的可能原因</h4><ul><li>锁阻塞，等待上一个事务提交完成后才能继续执行。</li><li>等flush，有其他语句在使用当前表，导致flush阻塞，导致查询阻塞。</li><li>两个事务，且查询语句所在的事务用的是一致性读，万一另外一个事务修改了n多次表，本事务就得不断地用undo_log来恢复，给语句加锁让其成为当前读，lock in share mode /  for update</li></ul><h4 id="9、next-key-lock-和-间隙锁"><a href="#9、next-key-lock-和-间隙锁" class="headerlink" title="9、next-key lock 和 间隙锁"></a>9、next-key lock 和 间隙锁</h4><ul><li>next-key lock 是行锁和间隙锁的合称，范围是每两个索引之间的区间，例如(5,10]，(10,15]，是一个左开右闭的区间。间隙锁解决索引区间内的并发插入导致的事务混乱。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM笔记</title>
    <link href="/2022/10/14/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/14/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习笔记"><a href="#JVM学习笔记" class="headerlink" title="JVM学习笔记"></a>JVM学习笔记</h1><h2 id="1、JVM运行时数据区"><a href="#1、JVM运行时数据区" class="headerlink" title="1、JVM运行时数据区"></a>1、JVM运行时数据区</h2><p><img src="C:\Users\TyanK\Desktop\MyBlog\source\img\image-20220529144146864.png" alt="image-20220529144146864"></p><h3 id="1-1程序计数器"><a href="#1-1程序计数器" class="headerlink" title="1.1程序计数器"></a>1.1程序计数器</h3><p>是一块较小的内存空间，线程的切换需要依赖程序计数器来恢复，程序计数器用于记录当前线程的执行位置，是唯一一个不会OOM的内存区域，会随着线程的创建而创建，死亡而死亡。</p><h3 id="1-2-JVM栈"><a href="#1-2-JVM栈" class="headerlink" title="1.2 JVM栈"></a>1.2 JVM栈</h3><p>线程私有，和线程共存亡，JVM运行时数据区核心区域，除了一些Native方法在本地方法栈运行，其他的Java方法都是通过调用栈来运行。每一个方法都会生成一个栈帧压入栈中，方法结束就弹出栈，栈帧包括局部变量表，操作数栈，动态链接，方法返回地址。</p><p><img src="https://javaguide.cn/assets/stack.357796df.png" alt="栈"></p><ul><li>局部变量表：存放编译时期可知的数据类型（int，boolean，double，char….），对象引用类型（reference）。</li><li>操作数栈：方法调用的中转站，用来存放一些计算中产生的中间计算结果，计算过程产生的临时变量也会存放在操作数栈中。</li><li>动态链接：当前方法用来调用其他方法的作用</li></ul><p>​    在栈空间不能动态扩展的情况下，栈空间不是无限的，如果栈中压入太多的栈帧导致栈满会报出 StackOverflow的错误。java方法的返回（return） 或者抛出异常（throw Exception） 都会弹出栈帧。栈帧随着方法的调用而创建，方法结束而销毁。除了栈溢出，如果栈空间可以动态扩展，可能还会出现Out Of Memory 错误，说明JVM栈无法申请到更多的空间。</p><h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。</p><h3 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h3><p>JVM所管理的内存中最大的一块，是所有线程共享的一块内存区域，在JVM启动时创建。<strong>唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存</strong>。GC垃圾回收的主要区域就是堆。</p><p>按照分代垃圾回收算法可以把堆再细分 ==新生代==，==老年代==，==永久代（元空间）==。</p><p>Eden（伊甸区），Survivor 幸存者区 (S0,S1) ，都属于新生代。</p><p><img src="https://javaguide.cn/assets/hotspot-heap-structure.784465da.png" alt="hotspot-heap-structure"></p><p>元空间使用的是直接内存。</p><p>对象的流程：</p><p>刚开始创建对象实在Eden区，第一次垃圾回收如果对象还存在的话就会下下放到幸存者区S0或S1，并且对象年龄+1，当年龄加到一定阈值时（15），就会放到老年代中。</p><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><p>方法区是JVM运行时数据的一块逻辑区域，是各个线程共享的内存区域。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p>永久代，元空间和方法区的关系就类似于类和接口，元空间是HotSpot虚拟机对虚拟机规范方法区中的实现方式。</p><p>JDK1.8 之后就不用永久代实现，改为元空间。</p><p>区别：</p><ul><li>永久代有一个JVM本身设置的固定大小上限，而元空间使用的是直接内存，受限于本机可用内存的限制。</li></ul><h3 id="1-6-常量池"><a href="#1-6-常量池" class="headerlink" title="1.6 常量池"></a>1.6 常量池</h3><ul><li><p>运行时常量池</p></li><li><p>字符串常量池 ：JVM为了提升性能和减少内存消耗针对String类专门开辟的一块区域，主要是避免字符串的重复创建。</p><p>常量池的实现是StringTable，本质是一个HashSet<String>。JDK1.7 之前存放在永久代，之后存放在堆中。JDK1.8 之后存放在了堆中。</p></li></ul><h3 id="1-7-一个对象创建的过程"><a href="#1-7-一个对象创建的过程" class="headerlink" title="1.7 一个对象创建的过程"></a>1.7 一个对象创建的过程</h3><ol><li><p>类加载检查，虚拟机收到一个new指令，会检查这个指令的参数能不能再常量池定位到这个符号引用，没有的话就执行相应的类加载。</p></li><li><p>分配内存，类加载检查通过后，对象所需的内存大小就确定了，从JVM堆分出一点内存给对象，分配方式又指针碰撞，空闲列表。</p><p>取决于Java堆的空间是否规整决定，Java堆是否规整又取决于GC垃圾收集器是如何收集垃圾的。</p><ol><li>==指针碰撞==，堆内存规整，有一个空闲指针分开已使用内存和未使用内存，把指针向未使用指针移动对象内存大小位置就行。</li><li>==空闲列表==，堆内存不规整，用一个列表来记录那些内存块是可用的，分配的时候对应对象所需的内存在列表中找到对应内存大小的内存块分配就可以，然后更新列表记录。</li><li>内存分配并发问题，JVM为保证线程安全，有两个机制<ul><li>CAS + 失败重试</li><li>TLAB：为每一个线程先在Eden区分配部分内存，JVM给线程分配内存时，先在TLAB里分配，如果TLAB没内存了，在使用以上这种。</li></ul></li></ol></li><li><p>初始化零值，将分配到的内存空间都分配零值，除了对象头。</p></li><li><p>设置对象头，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。</p></li><li><p>执行 init方法。</p></li></ol><p>在HotSpot虚拟机中，对象的内存布局可以分为：对象头，实例数据和对齐填充。</p><p>对象头存储对象自身运行时的数据，如哈希码，GC分代年龄，锁状态标志等</p><p>实例数据存放对象的有效信息，就是程序中定义的各种字段的内容。</p><p>对齐填充就是起到占位的作用，因为HotSPot虚拟机要求对象起始地址必须是8字节的整数倍数，没对齐的话就需要字节填充。</p><h3 id="1-8-垃圾回收"><a href="#1-8-垃圾回收" class="headerlink" title="1.8 垃圾回收"></a>1.8 垃圾回收</h3><p>可达性分析：</p><p>从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用。</p><p>弱引用在GC时会被回收，软引用在OOM之前会被回收，当然一个引用不在Reference chain上是必然会被回收的。</p><h5 id="垃圾回收算法："><a href="#垃圾回收算法：" class="headerlink" title="垃圾回收算法："></a>垃圾回收算法：</h5><p>标记清除法：</p><p>​    利用可达性分析来标记存活对象和垃圾对象，遍历一遍把所有的标记垃圾的对象回收，会有内存碎片，内存空间不连续，不好分配大的对象，可能又会导致一次GC。</p><p>标记整理法：</p><p>利用可达性分析标记存活对象和垃圾对象，将所有存活的对象向一段移动，将段外面的所有对象回收，不会产生空间碎片。</p><p>复制算法:</p><p>​    分代收集算法：根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收</p><p><img src="http://blog-img.coolsen.cn/img/image-20210329224002527.png" alt="image-20210329224002527"></p><h3 id="1-9-类加载器"><a href="#1-9-类加载器" class="headerlink" title="1.9 类加载器"></a>1.9 类加载器</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类</li></ol><h2 id="面试考点："><a href="#面试考点：" class="headerlink" title="面试考点："></a>面试考点：</h2><ol><li><h3 id="内存泄漏问题："><a href="#内存泄漏问题：" class="headerlink" title="内存泄漏问题："></a>内存泄漏问题：</h3><ul><li>对象在堆中不再使用，然而垃圾回收器无法清除它们，导致不断占用空间。内存泄漏十分不好因为它锁住了部分内存资源并且逐渐降低系统的性能。并且如果无法处理它，应用程序最终会耗尽所有资源最终产生一个致命的错误 – *<code>java.lang.OutOfMemoryError</code>*。</li></ul></li><li><h3 id="内存泄漏原因："><a href="#内存泄漏原因：" class="headerlink" title="内存泄漏原因："></a>内存泄漏原因：</h3></li></ol><ul><li><p>大量使用静态字段：</p><p>如何解决：减少static变量的使用 、使用单例模式时采用懒加载并非立即加载。</p></li><li><p>未关闭资源导致内存泄漏</p><p>例如数据库连接，输入流或对话对象这种需要开启的流，忘记关闭流就会导致内存被锁，一直被占用，无法被回收，资源产生的连接会消耗内存殆尽。</p><p>如何解决：始终用finally语句块来关闭连接、关闭资源的代码块不能包含异常（包括finally）。</p></li><li><p>对象的equals和hashcode方法不正当实现，会导致相同的对象无法被识别，就会创造出大量相同内容的对象。</p><p>定义新实体的时候重写equals和hashcode方法并以最佳方式实现。</p></li><li><p>引用外部类的内部类，一般的非静态内部类都会包含被外部类的隐式引用，所以创建一个内部类对象，他会因为一直被外部类引用而无法被回收。</p><p>如果内部类不需要访问外部类的非静态成员，则把它设为静态内部类。</p></li><li><p>ThreadLocal + 线程池：每个线程都会持有其 ThreadLocal 变量副本的隐式引用，一般线程结束的时候ThreadLocal也会被回收，但是由于使用了线程池，例如Tomcat 应用服务器，线程会被复用，这就导致了如果不显示清除的话，ThreadLocal会一直存在被引用，就回收不了，导致内存泄漏。</p><p>解决，使用remove来清除ThreadLocal变量中的线程，不要使用set null 方法，无用的，最好在finally中调用remove方法。</p></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程</title>
    <link href="/2022/10/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-多线程笔记"><a href="#Java-多线程笔记" class="headerlink" title="Java 多线程笔记"></a>Java 多线程笔记</h1><h2 id="1、几种线程类"><a href="#1、几种线程类" class="headerlink" title="1、几种线程类"></a>1、几种线程类</h2><h3 id="1-1-Thread类"><a href="#1-1-Thread类" class="headerlink" title="1.1 Thread类"></a>1.1 Thread类</h3><ol><li>继承Thread类，调用start方法以启动线程，</li></ol><h3 id="1-2-Runnable接口"><a href="#1-2-Runnable接口" class="headerlink" title="1.2 Runnable接口"></a>1.2 Runnable接口</h3><ol><li>实现Runnable接口，调用run方法，</li></ol><h3 id="1-3-Callable接口"><a href="#1-3-Callable接口" class="headerlink" title="1.3 Callable接口"></a>1.3 Callable接口</h3><ol><li>与Runnable接口类似，但是可以返回值，并且有泛型，返回一个Future类，用它的get方法得到返回值。</li></ol><h2 id="2、线程组"><a href="#2、线程组" class="headerlink" title="2、线程组"></a>2、线程组</h2><ol><li><p>每个Thread都有一个ThreadGroup</p></li><li><p>线程的优先级默认为5，可以用setPriority()方法重新设置优先级，但其实最终优先级还是依照操作系统的优先级，依它怎么调度的，看他的线程调度算法，线程的最大优先级还是依照线程组的优先级来算的。</p></li><li><p>守护线程Daemon，所有非守护线程结束后，守护线程也会自动结束。</p><p>线程组源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadGroup</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup parent;<br>    String name;<span class="hljs-comment">//组名</span><br>    <span class="hljs-type">int</span> maxPriority;<span class="hljs-comment">//线程最大优先级</span><br>    <span class="hljs-type">boolean</span> destroyed;<span class="hljs-comment">//是否被销毁</span><br>    <span class="hljs-type">boolean</span> daemon;<span class="hljs-comment">//是否守护线程</span><br>    <span class="hljs-type">boolean</span> vmAllowSuspension;<span class="hljs-comment">//能否中断</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nUnstartedThreads</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> nthreads;<span class="hljs-comment">//线程组中线程数目</span><br>    Thread threads[];<span class="hljs-comment">//线程数组</span><br>    <span class="hljs-type">int</span> ngroups;<span class="hljs-comment">//线程组数目</span><br>    ThreadGroup groups[];<span class="hljs-comment">//线程组数组</span><br><br></code></pre></td></tr></table></figure></li></ol><h2 id="3、Java线程的六个状态以及转换方式"><a href="#3、Java线程的六个状态以及转换方式" class="headerlink" title="3、Java线程的六个状态以及转换方式"></a>3、Java线程的六个状态以及转换方式</h2><h3 id="1、Java-的六个线程状态"><a href="#1、Java-的六个线程状态" class="headerlink" title="1、Java 的六个线程状态"></a>1、Java 的六个线程状态</h3><ul><li><strong>NEW   新创建还未启动</strong></li><li><strong>RUNNABLE   正在运行时 / 等待I/O资源</strong></li><li><strong>BLOCKED  阻塞状态，等待锁进入同步区</strong></li><li><strong>WAITING  等待状态，只能被动唤醒</strong></li><li><strong>TIMED_WAITING  等待状态，到时间自动唤醒</strong></li><li><strong>TERMINATED  终止状态</strong></li></ul><h3 id="2、转换方式如图"><a href="#2、转换方式如图" class="headerlink" title="2、转换方式如图"></a>2、转换方式如图</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXQFkYWhfJUhibHcHb4VoVp9Je8FwJvhEDcn1zwhktV7iaTjkozU2LoiaqO3XP5fDibWichGyJ5uwN3cqnQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="4、线程通信"><a href="#4、线程通信" class="headerlink" title="4、线程通信"></a>4、线程通信</h2><h3 id="1、锁与同步"><a href="#1、锁与同步" class="headerlink" title="1、锁与同步"></a>1、锁与同步</h3><h4 id="1-1-Synchronized"><a href="#1-1-Synchronized" class="headerlink" title="1.1 Synchronized"></a>1.1 Synchronized</h4><p>经典同步锁 Synchronized，保证一个资源同时只能一个线程使用，方式并发导致的数据错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MT1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;MT1: &quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MT2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;MT2: &quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MT1</span>()).start();<br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MT2</span>()).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\TyanK\AppData\Roaming\Typora\typora-user-images\image-20220416173110294.png" alt="image-20220416173110294"></p><p>结果lock需要等MT1运行完才会释放给MT2。</p><h4 id="1-2-等待通知机制"><a href="#1-2-等待通知机制" class="headerlink" title="1.2 等待通知机制"></a>1.2 等待通知机制</h4><p>线程不需要一直去尝试获得锁，等待上一个进程用完了就通知它。</p><p><strong>使用notify()方法唤醒，使用wait()方法释放资源并进入等待。</strong></p><h4 id="1-3-信号量机制"><a href="#1-3-信号量机制" class="headerlink" title="1.3 信号量机制"></a>1.3 信号量机制</h4><p><strong>使用volatile关键字。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">signal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>volatile变量需要原子操作。</p><h4 id="1-4-join、wait、sleep方法区别"><a href="#1-4-join、wait、sleep方法区别" class="headerlink" title="1.4 join、wait、sleep方法区别"></a>1.4 join、wait、sleep方法区别</h4><p>这三中方法都是让线程进入阻塞状态。</p><ol><li>join方法是让当前类进入等待，然后等join的这个线程执行完之后，再继续执行当前线程，底层其实还是利用了wait方法。</li><li>sleep方法，让线程睡眠等待一段时间，必须指定时间，会释放CPU资源，但不会释放当前的锁，容易死锁。可以任意放置。</li><li>wait方法，让线程睡眠等待，可以指定时间，也可以没有，释放CPU资源同时释放锁，只能放在同步块或同步方法。</li></ol><h4 id="1-5-ThreadLocal类"><a href="#1-5-ThreadLocal类" class="headerlink" title="1.5 ThreadLocal类"></a>1.5 ThreadLocal类</h4><p>让每一个线程都拥有自己的变量，线程互不影响。线程取值只能取到自己的变量值。</p><h2 id="5、Java内存模型"><a href="#5、Java内存模型" class="headerlink" title="5、Java内存模型"></a>5、Java内存模型</h2><h3 id="1、常见并发通信模型"><a href="#1、常见并发通信模型" class="headerlink" title="1、常见并发通信模型"></a>1、常见并发通信模型</h3><ul><li>共享内存：线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。</li><li>消息传递：线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</li></ul><p>Java使用的是共享内存模型，称为**Java内存模型(JMM)**，java线程之间的通信就由JMM控制。</p><h3 id="2、顺序一致性模型（理想化模型）"><a href="#2、顺序一致性模型（理想化模型）" class="headerlink" title="2、顺序一致性模型（理想化模型）"></a>2、顺序一致性模型（理想化模型）</h3><p>​    当前线程把写过的数据缓存到本地内存中，在没刷到新到主内存之前，其他线程是看不到这个写操作的，所以当前线程和其他线程的执行顺序就不一样，就需要顺序一致性模型，<strong>即每个操作必须对任意线程可见</strong>，<strong>然而JMM做不到这种任意线程透明可见的程度，所以叫理想化模型，除非加同步锁。</strong></p><ul><li>对于已同步程序的顺序一致性执行结果：正常</li><li>未同步：JMM只提供最小安全性，不能保证和已同步的结果一致。</li></ul><h3 id="3、happens-before规则"><a href="#3、happens-before规则" class="headerlink" title="3、happens-before规则"></a>3、happens-before规则</h3><ol><li>如果⼀个操作happens-before另⼀个操作，那么第⼀个操作的执⾏结果将对第 ⼆个操作可⻅，⽽且第⼀个操作的执⾏顺序排在第⼆个操作之前。</li></ol><p><strong>总之，如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作 B都是可⻅的，不管它们在不在⼀个线程。</strong></p><h2 id="6、volatile"><a href="#6、volatile" class="headerlink" title="6、volatile"></a>6、volatile</h2><h3 id="1、两大功能"><a href="#1、两大功能" class="headerlink" title="1、两大功能"></a>1、两大功能</h3><ul><li>保证变量的内存可见性</li><li>禁⽌volatile变量与普通变量重排序</li></ul><p>​    所谓内存可⻅性，指的是当⼀个线程对 volatile 修饰的变量进⾏写操作时，JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到主内 存；当⼀个线程对 volatile 修饰的变量进⾏读操作时，JMM⽴即把该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。</p><h3 id="2、如何禁止重排序"><a href="#2、如何禁止重排序" class="headerlink" title="2、如何禁止重排序"></a>2、如何禁止重排序</h3><ul><li>volatile引入了内存屏障，即在volatile读写操作之间加一个屏障以禁止重排序</li><li>LoadLoad ，StoreStore 、LoadStore、StoreLoad 屏障。</li></ul><h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><p>双重锁检查单例模式。</p><h2 id="7、Synchronized与锁"><a href="#7、Synchronized与锁" class="headerlink" title="7、Synchronized与锁"></a>7、Synchronized与锁</h2><p><strong>Java多线程的锁都是基于对象的</strong></p><h3 id="1、Synchronized关键字"><a href="#1、Synchronized关键字" class="headerlink" title="1、Synchronized关键字"></a>1、Synchronized关键字</h3><ul><li>写在static 方法上，锁为当前class</li><li>写在实例方法上，锁为当前实例</li><li>写在代码块上，锁为括号里的对象</li></ul><h3 id="1-1-Synchronized底层原理"><a href="#1-1-Synchronized底层原理" class="headerlink" title="1.1 Synchronized底层原理"></a>1.1 Synchronized底层原理</h3><p><strong>同步语句块通过 monitorenter 和 monitorexit实现</strong>，代表开始和结束，monitor基于cpp实现的，wait/notify也是依赖于monitor对象。同步方法没有这俩，取代的是一个标识 ACC_SYNCHRONIZED</p><h3 id="1-2-Synchronized-和-ReentrantLock-（可重入锁）的区别"><a href="#1-2-Synchronized-和-ReentrantLock-（可重入锁）的区别" class="headerlink" title="1.2 Synchronized 和 ReentrantLock （可重入锁）的区别"></a>1.2 Synchronized 和 ReentrantLock （可重入锁）的区别</h3><p>Synchronized 是基于JVM实现的，优化在虚拟机中，ReentrantLock基于JDK实现，优化再API中。</p><p>ReentrantLock增加了一些功能：</p><ul><li>等待可中断：正在等待的线程可以选择放弃等待，选择去处理其他事情。</li><li>可实现公平锁。（Synchronized是非公平锁）</li></ul><h3 id="1-3-Synchronized-和-volatile-关键字的区别"><a href="#1-3-Synchronized-和-volatile-关键字的区别" class="headerlink" title="1.3 Synchronized 和 volatile 关键字的区别"></a>1.3 Synchronized 和 volatile 关键字的区别</h3><p>volatile 关键字是线程同步的轻量级实现，它只能作用于变量，Synchronized可以作用于方法和代码块。</p><p>volatile保证了内存的可见性，但保证不了原子性，Synchronized两者都可以保证。</p><p><strong>==volatile==关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性</strong></p><h3 id="2、几种锁"><a href="#2、几种锁" class="headerlink" title="2、几种锁"></a>2、几种锁</h3><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><h3 id="3、Java对象头"><a href="#3、Java对象头" class="headerlink" title="3、Java对象头"></a>3、Java对象头</h3><p>java每一个对象都有对象头</p><p><strong>组成</strong></p><ul><li>Mark Word 存储对象的锁信息或者hashcode</li><li>Class Metadata Address 存储到对象数据类型的指针</li><li>Array length 数组长度</li></ul><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>一个线程占用的时候，如果该锁没有被其他锁访问，就不需要触发同步，加锁的过程。</p><p>原理：</p><p>一个线程第一次进入同步块时，会在对象头和栈帧（栈中）中的锁记录里存偏向锁的线程Id,下次进入同步块的时候，就会检查锁的MarkWord里是不是自己的线程ID，如果是的话，说明这个线程已经获得过锁了，就不需要加锁或者解锁过程，如果不是的话，说明有其他的线程来争夺这个偏向锁，就会尝试更新锁里的线程ID，两种情况：</p><ul><li>更新成功，就说明之前的线程已经不存在了，更新为自己的线程ID</li><li>不成功，就会升级为轻量级锁。</li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><h2 id="8、乐观锁，悲观锁"><a href="#8、乐观锁，悲观锁" class="headerlink" title="8、乐观锁，悲观锁"></a>8、乐观锁，悲观锁</h2><ul><li>悲观锁：普通的锁，用于读少写多</li><li>乐观锁：无锁状态，所以免疫死锁，用于读多写少，发生争夺，==用CAS解决==</li></ul><h3 id="1、CAS概念"><a href="#1、CAS概念" class="headerlink" title="1、CAS概念"></a>1、CAS概念</h3><p><strong>三个值</strong>：</p><ul><li>V ：内存地址</li><li>E ： 预期值（旧值）Expected</li><li>Ｎ：新值　NEW</li></ul><p>​    如果 V==E 则更新为N，如果不等，说明有其他线程修改过了，就放弃，什么都不做。当然，这种操作不会发生在临界的时候，例如线程一正要改的时候被线程二先改好了，不存在的，这是一个原子操作。所以如果多个线程使用CAS修改一个变量，只会有一个线程胜出，其他被告知失败重新尝试，或者直接放弃。</p><h5 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h5><p>ABA问题</p><ul><li>线程1 读取内存中数据为A</li><li>线程2 修改数据为B</li><li>线程2 修改数据为A</li><li>线程1 对数据进行CAS操作</li></ul><p>这样因为内存中的数据还是A，所以线程一还是会执行CAS操作，但实际上已经被线程2修改过了，乐观锁并不知道数据已经改变过，因为他仅仅是基于值是否变化来判断。</p><p>在某些场景会有隐患，例如栈顶问题，一个栈的栈顶经过两次或多次变换又变回了原值，但是栈可能已经发生了变化。</p><p>解决方法：引入版本号，每次变化版本号+1，进行CAS的时候，不仅判断值，还要判断版本号，两者都没变才进行CAS操作。</p><h2 id="9、-ThreadLocal-原理"><a href="#9、-ThreadLocal-原理" class="headerlink" title="9、 ThreadLocal 原理"></a>9、 ThreadLocal 原理</h2><p>为每一个线程都保存一个本地变量副本，避免线程安全问题。</p><p>ThreadLocal 中的对象其实是存放在ThreadLocalMap中。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对</strong></p><p>以ThreadLocal为key，value可以存object类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>            table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>            table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>            size = <span class="hljs-number">1</span>;<br>            setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h4><p>ThreadLocalMap中的key ThreadLocal 是弱引用，而value是强引用，这样在gc的回收的时候，key可能会被清理掉，但是value不会被清理，这样就会造成key为null，value有值的情况，value永远都不会被gc回收，这样子就会产生内存泄漏。所以使用完ThreadLocal最好手动调用remove方法。</p><h2 id="10、线程池"><a href="#10、线程池" class="headerlink" title="10、线程池"></a>10、线程池</h2><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="Runnable-和-Callable-的区别"><a href="#Runnable-和-Callable-的区别" class="headerlink" title="Runnable 和 Callable 的区别"></a>Runnable 和 Callable 的区别</h4><p>Runnable 接口不会返回结果或者抛出异常，Callable可以。</p><h4 id="excute-和-submit-的区别"><a href="#excute-和-submit-的区别" class="headerlink" title="excute() 和 submit() 的区别"></a>excute() 和 submit() 的区别</h4><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><h4 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h4><p>推荐使用 ThreadPoolExcutor 类创建，</p><h2 id="11、AQS-框架"><a href="#11、AQS-框架" class="headerlink" title="11、AQS 框架"></a>11、AQS 框架</h2><p>AQS是一个再JUC包下的抽象类，抽象队列同步器。</p><p>使用AQS来构造锁和同步器。</p><h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><p>如果当前的共享资源空闲，将当前请求资源的线程设置为有效的工作线程，并将资源设置为锁定状态，当有其他的线程请求共享资源时，就需要一套线程阻塞等待以及被唤醒时的锁分配机制，这在AQS里面就是使用了阻塞队列，CLH队列锁。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/CLH.png" alt="enter image description here"></p><p>共享变量 state 使用volatile来修饰，保证线程可见性，修改值使用的是CAS进行原子操作，compareAndSetState()</p><h4 id="AQS-定义-共享资源的两种模式"><a href="#AQS-定义-共享资源的两种模式" class="headerlink" title="AQS 定义 共享资源的两种模式"></a>AQS 定义 共享资源的两种模式</h4><h5 id="Exclusive-独占模式"><a href="#Exclusive-独占模式" class="headerlink" title="Exclusive 独占模式"></a>Exclusive 独占模式</h5><p>只有一个线程能够执行，例如ReentrantLock，有公平锁和非公平锁两种形式</p><ul><li>公平锁：按照线程再队列中的排序，先到者先拿锁。</li><li>非公平锁：线程获取锁时，先进行两次的CAS操作去抢锁，没抢到再加入队列中。</li></ul><h5 id="Share-共享模式"><a href="#Share-共享模式" class="headerlink" title="Share 共享模式"></a>Share 共享模式</h5><p>多个线程可以同时执行，例如semaphore和 countDownLatch、ReentrantReadWriteLock。</p><hr>**自定义同步器只需要实现共享资源的获取和释放方式就可以，线程的等待队列的维护AQS已经在上层给我们实现好了。**<hr><p>复习细节:</p><p>java线程状态，new Runnable,block,wait,terminated</p><p>死锁必须具备的四个条件：</p><p>互斥，请求保持，不可剥夺，循环等待。要防止死锁可以破坏其中随意一个条件即可。</p><p>sleep和wait的区别，Thread.sleep()，Object.wait()，不是通过一个类。sleep阻塞是让线程睡眠一段时间，然后等时间到了自动唤醒，解除阻塞，进入Runnable状态，睡眠的时候不会释放锁。</p><p>wait要配合synchronize一起使用，进入阻塞状态后需要调用notify或者notifyAll方法才能唤醒，因为在阻塞的时候会释放锁，这样就只有在唤醒之后获得锁的线程才能进入Runnable状态。</p><p>两种方法都可以让线程阻塞。</p><p>synchronize 底层原理，使用的是监视器模式：</p><p>编译好的字节码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">4: monitorenter<br>5: getstatic    <span class="hljs-comment">#9    // Field java/lang/System.out:Ljava/io/PrintStream; </span><br>8: ldc           <span class="hljs-comment">#15   // String hello</span><br>10: invokevirtual <span class="hljs-comment">#17  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>13: aload_1<br>14: monitorexit<br></code></pre></td></tr></table></figure><p>monitorenter ,monitorexit，监视进入，监视退出。</p><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p>1、进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p><p>2、多线程上下文切换，线程数大于给程序分配的CPU数量，为了让每个线程都有时间片执行，要轮转使用CPU，不同线程切换时需要保存数据信息切换线程就被称为上下文切换。</p><p>3、死锁与活锁、饥饿，死锁是状态一直不会变的，死锁则是一直处于等待的状态。</p><p>线程饥饿原因：</p><ol><li>高优先级线程一直抢夺低优先级线程的时间片。</li><li>线程永久被堵塞在一个同步块，其他线程总是快它一步。</li><li>线程在等待一个处于永久等待的对象</li></ol><p>4、创建线程调用start方法不直接调用run方法，原因是调用start方法是才会创建线程并且执行run方法，初始化分配方法栈和程序计数器，如果直接调用run方法只会当作普通方法执行。</p><p>5、</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/14/hello-world/"/>
    <url>/2022/10/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
